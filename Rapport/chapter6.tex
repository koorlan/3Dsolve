Dans ce chapitre, nous allons aborder les aspects techniques li√©s au d√©veloppement de notre application.

\section{Le format de fichier ``.snake''}
Les diff√©rents snakes propos√©s par l'application sont stock√©s dans des fichiers ``*.snake'' dans le r√©pertoire ``Snakes''. Le listing~\ref{.snake} ci-apr√®s montre le contenu du fichier ``snake.snake'' soit le serpent charg√© par d√©faut par l'application.\newline

La section \verb|[Volume]| permet de d√©finir les caract√©ristiques du volume final, soit :
\begin{itemize}
 \item sa largeur (x);
 \item sa hauteur (y);
 \item sa profondeur (z);
 \item l'√©tat de chacun des sous-cubes le formant (x;y;z;State).
\end{itemize}

La premi√®re ligne indique les dimensions (maximales, sur les trois axes) du volume final. L'exemple pr√©sent√© ici indique que le volume √  remplir est contenu dans un cube de 3x3x3. 
Ensuite, on associe √  chaque triplet de coordonn√©es un ``√©tat'', mat√©rialis√© par la derni√®re valeur enti√®re de chaque ligne. La valeur 1 signifie que le volume final occupe l'espace √  cette coordonn√©e. La valeur -1 indique au contraire que le volume final ne doit pas occuper cet emplacement.\newline

La section \verb|[Snake]| d√©finit le nombre et l‚Äôencha√Ænement des unit√©s formant le serpent. La valeur 0 indique que l'unit√© est une extr√©mit√© du serpent, la valeur 1 indique une unit√© de type ``droite'' et la valeur 2 une unit√© de type ``angle''.\newline

La section \verb|[Symetry]| permet quant √  elle de d√©finir quels sont les axes de sym√©trie √  prendre en compte lors de la recherche des vecteurs initiaux (cf partie 3.4). La valeur 1 repr√©sente le fait qu'un axe de sym√©trie est applicable aux faces du volume tandis que la valeur 0 indique qu'il ne convient pas de l'utiliser. Ces quatre entiers correspondent respectivement aux axes de sym√©trie vertical, horizontal, diagonal anti-slash et diagonal slash.

\newpage
\begin{lstlisting}[caption=Contenu du fichier snake.snake]
 [Volume]
  3;3;3
  0;0;0;1
  0;0;1;1
  0;0;2;1
  0;1;0;1
  0;1;1;1
  0;1;2;1
 
  [ ... ]
 
  2;1;1;1
  2;1;2;1
  2;2;0;1
  2;2;1;1
  2;2;2;1
  [Snake]
  27
  0;1;2;2;2;1;2;2;1;2;2;2;1;2;1;2;2;2;2;1;2;1;2;1;2;1;0;
  [Symetry]
  1;1;1;1
\end{lstlisting}\label{.snake}

\section{L'utilisation des threads}
Nous avons d√®s le d√©part pris le parti d'utiliser la technique du multithreading afin de s√©parer l‚Äôex√©cution du rendu 3D et le reste de l'application. Cela permet notamment de faciliter la gestion des animations et, de mani√®re plus g√©n√©rale, de limiter la d√©pendance du rendu 3D avec les diverses fonctions de calcul. 

Plus tard dans le d√©veloppement de l'application, nous avons √©tendu l'utilisation des threads au calcul des solutions. Cette parall√©lisation a permit d'am√©liorer le temps de calcul, en particulier pour le Snake Cube de taille 4x4x4.\newline

Le sch√©ma suivant (Fig.\ref{threads}) montre l'organisation des threads de notre programme. On distingue 4 types de threads :
\begin{itemize}
 \item Le thread principal, qui a pour r√¥le de cr√©er les autres thread et qui fait donc office de thread de contr√¥le. C'est √©galement lui qui se charge de l‚Äôinteraction homme/machine (r√©cup√©ration et interpr√©tation des entr√©es clavier/sourie).
 \item Le thread graphique √  qui il incombe d'actualiser l'√©cran de sorte √  avoir dans l'id√©al une fr√©quence de 60 images par seconde. Ce thread est d√©marr√© au lancement du programme et se termine lors de la fermeture du l'application.
 \item Le thread de calcul, dont le r√¥le est de r√©partir le travail de recherche des solutions aus diff√©rents threads de r√©solution de noeud. Ce thread permet de calculer les solutions pour un snake tout en laissant la possibilit√© √  l'utilisateur d'interagir avec l'application (pression sur la touche ``√©chap'' notamment. Ce thread est d√©marr√© en mode d√©tach√© pour rechercher toutes les solutions lorsque l'utilisateur charge un nouveau serpent. Il peu √©galement √™tre lanc√© en mode attach√© (attente de la fin de l‚Äôex√©cution) lorsque l'utilisateur demande une aide √  la r√©solution. Ce d√©marrage en mode attach√© repr√©sente une contrainte que nous n'avons pas eu le temps de contourner. En effet, quand ce thread est en mode attach√©, il perd sa capacit√© √  totalement parall√©liser le travail de recherche. L'utilisateur ne peut donc plus interagir avec l'application pendant le calcul, le thread principal √©tant bloqu√© par l'attente de la fin de l'ex√©cution du thread de calcul.
 \item Les thread de r√©solution de noeud; ces threads sont cr√©√©s par le thread de calcul. Ils permettent d'explorer plusieurs branches de l'arbre de recherche en m√™me temps, permettant ainsi de r√©duire le temps de calcul. Le nombre de points de d√©part (de branches) √  explorer pour chaque thread de r√©solution de noeud est d√©finit de la mani√®re suivante : soit n le nombre de thread de r√©solution de noeud √  utiliser et x le nombre de points de d√©part possible pour r√©soudre le snake. Le nombre de point d√©part affect√©s au n-1 premier thread sera a = x / n. Pour le n\up{i√®me} thread, le nombre de point de d√©part affect√©s sera b = n - ((n-1) * a). Nous verrons dans la partie ``R√©sultats'' que cette fa√ßon de faire pr√©sente un inconv√©nient.
\end{itemize}

\begin{figure}[h]
 \centering
 \includegraphics[scale=0.4,keepaspectratio=true]{img/threads.png}
 \caption{Organisation des threads}
 \label{threads}
\end{figure}